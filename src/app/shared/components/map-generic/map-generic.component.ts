import { Component, ElementRef, Input, OnInit, Output, EventEmitter, ViewChild, SimpleChanges } from '@angular/core';
import { MapData } from '../../interfaces/MapData.interface';
import { MapSvg } from '../../interfaces/maps_svg.interface';
import { MapDataService } from '../../services/map-data/map-data.service';
import { MapSvgService } from '../../services/map-svg/map-svg.service';
import { AreaStatus } from './mapColorationUtils/AreaStatus.enum';
import { colorArea } from './mapColorationUtils/colorArea';
import { colorAreas } from './mapColorationUtils/colorAreas';

import { pan, zoom, resetTransform, Coordinates } from './mapTransformUtils/index';
import { removeLandsColoration } from './mapTransformUtils/removeLandsColoration';

@Component({
  selector: 'app-map-generic',
  templateUrl: './map-generic.component.html',
  styleUrls: ['./map-generic.component.scss']
})
export class MapGenericComponent implements OnInit {

  @Output('areaSelected') areaSelected: EventEmitter<MapData> = new EventEmitter<MapData>();

  @Input('colorGroup') colorGroup: boolean = false;

  @Input('inGame') inGame: true | undefined = undefined;
  @Input('foundList') foundList: MapData[] = [];

  @ViewChild('mapRef') mapRef: ElementRef<SVGSVGElement> | undefined;
  @ViewChild('groupRef') groupRef: ElementRef<SVGGElement> | undefined;

  @Input('mapId') mapId: string = "";

  @Input('currentSelected') currentSelected: MapData | undefined = undefined;

  @Input('visibleBorder') visibleBorder: boolean = true;

  loadedMap: MapSvg | undefined = undefined;
  loadedData: MapData[] | undefined = undefined;
  /**
   * sets the consultation windows position on right or left of the map
   */
  consultationSide: "left" | "right" = "left";


  mouseStates: MouseStates = {
    isPanned: false,
    isClickDown: false,
    pointerDownEvents: [],
    lastX: 0,
    lastY: 0
  }

  /**
   * Represents the id of an interval. When launched, equals the id of the generated interval. When want to stop, then just clear the interval via its ID
   */
  scallingIntervalId: number | undefined = undefined;

  pinchingTimeoutId: number | undefined = undefined;

  currentSelectedArea: string = "";

  /**
   * Allows to know the state of the map :Panned, scaled or else.
   * Should never be null.
   */
  private currentMatrix!: DOMMatrix;

  constructor(private mapSvgService: MapSvgService, private mapDataService: MapDataService) { }

  ngOnInit(): void { }

  ngOnChanges(changes: SimpleChanges) {
    if (changes.mapId) this.onMapIdChange(changes.mapId.currentValue);
    if (changes.currentSelected) if (changes.currentSelected.currentValue !== undefined) this.areaClick((changes.currentSelected.currentValue as MapData).id);
  }

  /**
   * Loads maps svg and related data
   */
  onMapIdChange(mapId: string) {
    if (!mapId) return; // If there is no value then skip
    this.loadMapSvg(mapId);
    this.loadMapData(mapId);
  }


  /**
   * Loads the svg for a given map
   * @param mapId The map index entry corresponding to the wanted svg
   */
  private loadMapSvg(mapId: string) {
    this.mapSvgService.getMapSvg(mapId).subscribe(svg => {
      this.loadedMap = svg;
      // Make it so transform matrix wait for the map to be fully generated by Ivy before effectively be created
      setTimeout(() => { this.resetTransform(); }, 100);
    });
  }
  private loadMapData(mapId: string) {
    this.mapDataService.getMapData(mapId).subscribe(data => {
      this.loadedData = data;
    });
  }

  /**
   * On an area click, search on associated data list the corresponding id. Colors the area and its group
   * @param event The mouse click event. We get the area node from it
   */
  areaClick(areaId: string): void {
    removeLandsColoration();
    this.currentSelected = this.loadedData!.find(e => e.id === areaId);
    this.areaSelected.emit(this.currentSelected);
    if (!this.currentSelected) return;
    console.log(this.currentSelected);

    colorArea(areaId, AreaStatus.SELECTED);
    colorAreas(this.currentSelected!.id, this.currentSelected!.group);
  }

  /**
   * Sets current mousestates as `panning`
   * @param event
   */
  panningBegin(event: MouseEvent) {
    if (event instanceof PointerEvent) {
      this.mouseStates.pointerDownEvents.push(event);
    }

    if (event.button === 1 || !matchMedia('(pointer:fine)').matches) {
      event.preventDefault();
      this.mouseStates.isPanned = true;
    }
  }

  /**
   * Sets current mousestates as not `panning`
   * @param event
   */
  panningEnd(event: MouseEvent) {
    this.mouseStates.lastX = 0;
    this.mouseStates.lastY = 0;
    if (event instanceof PointerEvent) {
      this.mouseStates.pointerDownEvents = this.mouseStates.pointerDownEvents.filter(e => e.pointerId !== event.pointerId);
    }
    if (event.button === 1 || !matchMedia('(pointer:fine)').matches) {
      event.preventDefault();
      this.mouseStates.isPanned = false;
    }
  }

  /**
   * Apply correct transform on map depending on : If on mobile, if pinching, if middle click
   * @param mouseMove A mouseMove event that may be of type PointerEvent (case of mobile)
   */
  pointerMove(mouseMove: MouseEvent) {
    // If on mobile device
    if (mouseMove instanceof PointerEvent) {
      // Find this event in the cache and update its record with this event
      this.mouseStates.pointerDownEvents[this.mouseStates.pointerDownEvents.findIndex(e => mouseMove.pointerId == e.pointerId)] = mouseMove;
    }
    // If two pointer at a time, then check if should try to zoom
    if (this.mouseStates.pointerDownEvents.length == 2) {
      if (!this.pinchingTimeoutId) {
        // Set a timeout to debounce pinch event that can trigger many events at a time
        this.pinchingTimeoutId = window.setTimeout(() => { this.pinchingTimeoutId = undefined }, 50);
        let firstPointer = this.mouseStates.pointerDownEvents[0],
          secondPointer = this.mouseStates.pointerDownEvents[1];
        // Origin distance between pointers
        let originDist = Math.sqrt((firstPointer.clientX - secondPointer.clientX) ** 2
          + (firstPointer.clientY - secondPointer.clientY) ** 2);
        // Distance between pointers after mov
        let newDist = Math.sqrt(((firstPointer.x + firstPointer.movementX) - (secondPointer.x + secondPointer.movementX)) ** 2
          + ((firstPointer.y + firstPointer.movementY) - (secondPointer.y + secondPointer.movementY)) ** 2);
        this.zoom((newDist - originDist) / window.devicePixelRatio * 15, { x: (secondPointer.clientX + firstPointer.clientX) / 2, y: (secondPointer.clientY + firstPointer.clientY) / 2 });
      }
    } else if (this.mouseStates.pointerDownEvents.length == 1) {
      // if first move on panning, then do not move (else you'll get a X - 0 which makes the map take your thumb as origin)
      if (this.mouseStates.lastX !== 0 && this.mouseStates.lastY !== 0) {

        mouseMove.preventDefault();
        this.panning(mouseMove.clientX - this.mouseStates.lastX, mouseMove.clientY - this.mouseStates.lastY);
      }
    }
    // Register last positions
    this.mouseStates.lastX = mouseMove.clientX;
    this.mouseStates.lastY = mouseMove.clientY;
  }

  /**
   * Gives the deltas to apply on map to pan
   * @param mouseMove
   */
  panning(movementX: number, movementY: number) {
    if (this.mouseStates.isPanned) {
      this.pan({ x: movementX, y: movementY })
    }
  }

  /**
   * Apply the panning to the map
   * @param deltaCoordinates
   */
  pan(deltaCoordinates: Coordinates) {
    this.currentMatrix = pan({
      currentTransform: this.currentMatrix,
      containerElement: this.mapRef!.nativeElement,
      toPanElement: this.groupRef!.nativeElement,
      deltaCoordinates: deltaCoordinates
    });
  }

  /**
   * Scalling with the wheel
   * @param event
   */
  wheelEvent(event: WheelEvent) {
    event.preventDefault();
    let coordinates = {
      x: event.x,
      y: event.y
    };
    this.zoom(-event.deltaY, coordinates);
  }
  /**
   * Scalling in or out
   */
  scaleClick(zoomIn: boolean) {
    // If no current scalling loop, then do nothing
    if (!this.scallingIntervalId) {
      this.scallingIntervalId = window.setInterval(() => {
        let element: DOMRect = this.mapRef!.nativeElement.getBoundingClientRect();
        let coordinates = {
          x: element.width / 2 + element.x,
          y: element.height / 2 + element.y
        };
        this.zoom((zoomIn ? 1 : -1) * 100, coordinates);
      }, 50);
    }
  }

  /**
   * Stops the zoom loop
   */
  zoomStop() {
    clearInterval(this.scallingIntervalId!);
    this.scallingIntervalId = undefined;
  }

  /**
   * Reset the map to its initial state
   */
  resetTransform() {
    this.currentMatrix = this.mapRef!.nativeElement.createSVGMatrix();
    resetTransform(this.mapRef!.nativeElement, this.groupRef!.nativeElement);
    this.setLandWidth(this.currentMatrix.a);
  }

  /**
   * Zooms in the map at the given coordinates for the given delta
   * @param scale A delta corresponding to the percentage to zoom (e.g : 0.8 or 1.2)
   * @param coordinates Some relative to a box coordinates to zoom to
   */
  zoom(scale: number, coordinates: { x: number, y: number }) {
    this.currentMatrix = zoom({
      deltaScale: scale,
      currentTransform: this.currentMatrix,
      containerElement: this.mapRef!.nativeElement,
      toScaleElement: this.groupRef!.nativeElement,
      coordinates: coordinates
    });
    this.setLandWidth(this.currentMatrix.a);
  }

  /**
   * Adapt the land stroke to the current scale
   * @param scale A scale to adapt to
   */
  setLandWidth(scale: number) {
    document.documentElement.style.setProperty('--land-stroke', (0.4 / scale) + "px");
  }

  mouseEnterConsultation() {
    this.consultationSide = this.consultationSide === "left" ? "right" : "left";
  }

  canCurrentSelectedBeDisplayed(mapData: MapData | undefined) {
    if (!mapData) return false;
    if (!this.inGame) return true;
    if (this.foundList.find(e=>e.id === mapData.id)) return true;
    return false;
  }
}


interface MouseStates {
  isPanned: boolean,
  isClickDown: boolean,
  pointerDownEvents: PointerEvent[],
  lastX: number,
  lastY: number
}
